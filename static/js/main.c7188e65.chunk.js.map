{"version":3,"sources":["pathFindingFunctions.js","mazeFunctions/randomizedDfsMaze.js","App.js","reportWebVitals.js","index.js"],"names":["getNeighbours","curNode","grid","node","neighbour","row","col","isWall","push","length","animateSearch","time","setTimeout","anime","targets","document","getElementById","concat","Math","floor","window","innerWidth","scale","value","easing","duration","background","borderRadius","animatePath","thisGetNeighbours","checkEmptyAdjacent","neighbours","count","i","checkEmptyDiagonal","anotherGetNeighbour","changeWhite","App","blankGrid","createGrid","useState","setGrid","isMousePressed","setIsMousePressed","innerHeight","startingNode","setStartingNode","endingNode","setEndingNode","isMovingStart","setIsMovingStart","isMovingEnd","setIsMovingEnd","grids","j","isStart","isEnd","createNode","className","id","style","width","height","border","display","justifyContent","alignItems","onMouseDown","newGrid","onMouseEnter","onMouseUp","backgroundColor","position","overflow","Button","variant","color","onClick","visitOrder","path","animateDijkstra","queue","visited","prev","result","found","visit","pre","splice","cur","dijkstra","order","anotherAnimateDfs","randIndex","random","unshift","createPath","flexDirection","map","renderGrid","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"+OAEA,SAASA,EAAcC,EAASC,GAC/B,IAqBKC,EArBDC,EAAY,GAEZH,EAAQI,IAAM,KACbF,EAAOD,EAAKD,EAAQI,IAAM,GAAGJ,EAAQK,MAC/BC,QACTH,EAAUI,KAAKL,IAGbF,EAAQK,IAAMJ,EAAK,GAAGO,OAAS,KAC9BN,EAAOD,EAAKD,EAAQI,KAAKJ,EAAQK,IAAM,IACjCC,QACTH,EAAUI,KAAKL,IAGbF,EAAQI,IAAMH,EAAKO,OAAS,KAC3BN,EAAOD,EAAKD,EAAQI,IAAM,GAAGJ,EAAQK,MAC/BC,QACTH,EAAUI,KAAKL,IAGbF,EAAQK,IAAM,KACbH,EAAOD,EAAKD,EAAQI,KAAKJ,EAAQK,IAAM,IACjCC,QACTH,EAAUI,KAAKL,IAGjB,OAAOC,EAqER,SAASM,EAAcP,EAAMQ,GAC5BC,YAAW,WACVC,YAAM,CACLC,QAASC,SAASC,eAAe,OAAOC,OAAOd,EAAKE,IAAMa,KAAKC,MAAMC,OAAOC,WAAa,IAAMlB,EAAKG,MACpGgB,MAAO,CACN,CAAEC,MAAO,IAAKC,OAAQ,cAAeC,SAAU,KAC/C,CAAEF,MAAO,EAAGC,OAAQ,gBAAiBC,SAAU,OAEhDC,WAAY,CACX,CAAEH,MAAO,UAAWC,OAAQ,SAAUC,SAAU,KAChD,CAAEF,MAAO,UAAWC,OAAQ,SAAUC,SAAU,MAEjDE,aAAc,CACb,CAAEJ,MAAO,MAAOC,OAAQ,SAAUC,SAAU,KAC5C,CAAEF,MAAO,KAAMC,OAAQ,SAAUC,SAAU,UAG3C,GAAKd,GAGT,SAASiB,EAAYzB,EAAMQ,GAC1BC,YAAW,WACVC,YAAM,CACLC,QAASC,SAASC,eAAe,OAAOC,OAAOd,EAAKE,IAAMa,KAAKC,MAAMC,OAAOC,WAAa,IAAMlB,EAAKG,MACpGgB,MAAO,CACN,CAAEC,MAAO,IAAKC,OAAQ,cAAeC,SAAU,KAC/C,CAAEF,MAAO,EAAGC,OAAQ,gBAAiBC,SAAU,OAEhDC,WAAY,CACX,CAAEH,MAAO,UAAWC,OAAQ,SAAUC,SAAU,KAChD,CAAEF,MAAO,UAAWC,OAAQ,SAAUC,SAAU,MAEjDE,aAAc,CACb,CAAEJ,MAAO,MAAOC,OAAQ,SAAUC,SAAU,KAC5C,CAAEF,MAAO,KAAMC,OAAQ,SAAUC,SAAU,UAG3C,GAAKd,GC9DT,SAASkB,EAAkB5B,EAASC,GAClC,IAAIE,EAAY,GAChB,GAAIH,EAAQI,IAAM,EAAG,CACnB,IAAIF,EAAOD,EAAKD,EAAQI,IAAM,GAAGJ,EAAQK,KACzCF,EAAUI,KAAKL,GAEjB,GAAIF,EAAQK,IAAMJ,EAAK,GAAGO,OAAS,EAAG,CAChCN,EAAOD,EAAKD,EAAQI,KAAKJ,EAAQK,IAAM,GAC3CF,EAAUI,KAAKL,GAEjB,GAAIF,EAAQI,IAAMH,EAAKO,OAAS,EAAG,CAC7BN,EAAOD,EAAKD,EAAQI,IAAM,GAAGJ,EAAQK,KACzCF,EAAUI,KAAKL,GAEjB,GAAIF,EAAQK,IAAM,EAAG,CACfH,EAAOD,EAAKD,EAAQI,KAAKJ,EAAQK,IAAM,GAC3CF,EAAUI,KAAKL,GAEjB,OAAOC,EA+ET,SAAS0B,EAAmB3B,EAAMD,GAGhC,IAFA,IAAI6B,EAAaF,EAAkB1B,EAAMD,GACrC8B,EAAQ,EACHC,EAAI,EAAGA,EAAIF,EAAWtB,OAAQwB,IAIrC,GAHKF,EAAWE,GAAG1B,QACjByB,IAEEA,GAAS,EACX,OAAO,EAGX,OAAO,EAGT,SAASE,EAAmB/B,EAAMD,GAChC,QAAIC,EAAKE,IAAM,GAAKF,EAAKG,IAAM,IACxBJ,EAAKC,EAAKE,IAAM,GAAGF,EAAKG,IAAM,GAAGC,QAAUL,EAAKC,EAAKE,IAAM,GAAGF,EAAKG,KAAKC,QAAUL,EAAKC,EAAKE,KAAKF,EAAKG,IAAM,GAAGC,YAIlHJ,EAAKE,IAAM,GAAKF,EAAKG,IAAMJ,EAAK,GAAGO,OAAS,IACzCP,EAAKC,EAAKE,IAAM,GAAGF,EAAKG,IAAM,GAAGC,QAAUL,EAAKC,EAAKE,IAAM,GAAGF,EAAKG,KAAKC,QAAUL,EAAKC,EAAKE,KAAKF,EAAKG,IAAM,GAAGC,YAIlHJ,EAAKE,IAAMH,EAAKO,OAAS,GAAKN,EAAKG,IAAM,IACtCJ,EAAKC,EAAKE,IAAM,GAAGF,EAAKG,IAAM,GAAGC,QAAUL,EAAKC,EAAKE,IAAM,GAAGF,EAAKG,KAAKC,QAAUL,EAAKC,EAAKE,KAAKF,EAAKG,IAAM,GAAGC,WAIlHJ,EAAKE,IAAMH,EAAKO,OAAS,GAAKN,EAAKG,IAAMJ,EAAK,GAAGO,OAAS,IACvDP,EAAKC,EAAKE,IAAM,GAAGF,EAAKG,IAAM,GAAGC,QAAUL,EAAKC,EAAKE,IAAM,GAAGF,EAAKG,KAAKC,QAAUL,EAAKC,EAAKE,KAAKF,EAAKG,IAAM,GAAGC,UAOxH,SAAS4B,EAAoBhC,EAAMD,GACjC,IAAIE,EAAY,GAahB,OAZID,EAAKE,IAAM,GACbD,EAAUI,KAAKN,EAAKC,EAAKE,IAAM,GAAGF,EAAKG,MAErCH,EAAKG,IAAMJ,EAAK,GAAGO,OAAS,GAC9BL,EAAUI,KAAKN,EAAKC,EAAKE,KAAKF,EAAKG,IAAM,IAEvCH,EAAKE,IAAMH,EAAKO,OAAS,GAC3BL,EAAUI,KAAKN,EAAKC,EAAKE,IAAM,GAAGF,EAAKG,MAErCH,EAAKG,IAAM,GACbF,EAAUI,KAAKN,EAAKC,EAAKE,KAAKF,EAAKG,IAAM,IAEpCF,EAGT,SAASgC,EAAYjC,EAAMQ,EAAMT,GAC/BU,YAAW,WACTC,YAAM,CACJC,QAASC,SAASC,eAAe,OAAOC,OAAOd,EAAKE,IAAMH,EAAK,GAAGO,OAASN,EAAKG,MAChFoB,WAAY,cAEb,GAAKf,G,WCvCK0B,MAzLf,WAEE,IAAMC,EAAYC,IAFL,EAGWC,mBAASD,KAHpB,mBAGNrC,EAHM,KAGAuC,EAHA,OAI+BD,oBAAS,GAJxC,mBAINE,EAJM,KAIUC,EAJV,OAK2BH,mBAAS,CAACtB,KAAKC,OAAOC,OAAOwB,YAAc,KAAO,IAAK1B,KAAKC,MAAMC,OAAOC,WAAa,MALjH,mBAKNwB,EALM,KAKQC,EALR,OAMuBN,mBAAS,CAACtB,KAAKC,OAAOC,OAAOwB,YAAc,KAAO,IAAK1B,KAAKC,MAA0B,EAApBC,OAAOC,WAAiB,MANjH,mBAMN0B,EANM,KAMMC,EANN,OAO6BR,oBAAS,GAPtC,mBAONS,EAPM,KAOSC,EAPT,OAQyBV,oBAAS,GARlC,mBAQNW,EARM,KAQOC,EARP,KAUb,SAASb,IAEP,IADA,IAAIc,EAAQ,GACHpB,EAAI,EAAGA,EAAIf,KAAKC,OAAOC,OAAOwB,YAAc,KAAO,IAAKX,IAAK,CAEpE,IADA,IAAI5B,EAAM,GACDiD,EAAI,EAAGA,EAAIpC,KAAKC,MAAMC,OAAOC,WAAa,IAAKiC,IACtDjD,EAAIG,KAAK,CACPH,IAAK4B,EACL3B,IAAKgD,EACL/C,QAAQ,EACRgD,SAAS,EACTC,OAAO,IAGXH,EAAM7C,KAAKH,GAEb,OAAOgD,EAmBT,SAASI,EAAWtD,GAClB,OACE,sBACEuD,UAAU,OACVC,GAAI,OAAO1C,OAAOC,KAAKC,MAAMC,OAAOC,WAAa,IAAMlB,EAAKE,IAAMF,EAAKG,KACvEsD,MAAO,CAAEC,MAAO,GAAIC,OAAQ,GAAIC,OAAQ,oBAAqBC,QAAS,OAAQC,eAAgB,SAAUC,WAAY,UACpHC,YAAa,WACX,GAAKhE,EAAKE,MAAQwC,EAAa,IAAM1C,EAAKG,MAAQuC,EAAa,GAI/D,GAAK1C,EAAKE,MAAQ0C,EAAW,IAAM5C,EAAKG,MAAQyC,EAAW,GAA3D,CAIA,IAAIqB,EAAO,YAAOlE,GACdD,EAAUmE,EAAQjE,EAAKE,KAAKF,EAAKG,KACrCL,EAAQM,QAAUJ,EAAKI,OACvB6D,EAAQjE,EAAKE,KAAKF,EAAKG,KAAOL,EAC9BwC,EAAQ2B,GACRzB,GAAkB,QARhBS,GAAe,QAJfF,GAAiB,IAcrBmB,aAAc,WACZ,GAAIpB,EAAe,CACjB,GAAK9C,EAAKE,MAAQ0C,EAAW,IAAM5C,EAAKG,MAAQyC,EAAW,GAAO,OAClE,GAAI5C,EAAKI,QAEHN,GADAmE,EAAO,YAAOlE,IACIC,EAAKE,KAAKF,EAAKG,MAC7BC,QAAUJ,EAAKI,OACvB6D,EAAQjE,EAAKE,KAAKF,EAAKG,KAAOL,EAC9BwC,EAAQ2B,GAEVtB,EAAgB,CAAC3C,EAAKE,IAAKF,EAAKG,MAGlC,GAAI6C,EAAa,CACf,GAAKhD,EAAKE,MAAQwC,EAAa,IAAM1C,EAAKG,MAAQuC,EAAa,GAAO,OACtE,GAAI1C,EAAKI,QAEHN,GADAmE,EAAO,YAAOlE,IACIC,EAAKE,KAAKF,EAAKG,MAC7BC,QAAUJ,EAAKI,OACvB6D,EAAQjE,EAAKE,KAAKF,EAAKG,KAAOL,EAC9BwC,EAAQ2B,GAEVpB,EAAc,CAAC7C,EAAKE,IAAKF,EAAKG,MAI9B,IAAI8D,EACAnE,EAFFyC,KAEEzC,GADAmE,EAAO,YAAOlE,IACIC,EAAKE,KAAKF,EAAKG,MAC7BC,QAAUJ,EAAKI,OACvB6D,EAAQjE,EAAKE,KAAKF,EAAKG,KAAOL,EAC9BwC,EAAQ2B,KAGZE,UAAW,WACLrB,GACFC,GAAiB,GAEfC,GACFC,GAAe,GAEbV,GACFC,GAAkB,IA7DxB,UAkEIxC,EAAKI,OACL,qBAAKqD,MAAO,CAAEC,MAAO,GAAIC,OAAQ,GAAIS,gBAAiB,WAEtD,6BAEApE,EAAKE,MAAQwC,EAAa,IAAM1C,EAAKG,MAAQuC,EAAa,GAC1D,sBAAKe,MAAO,CAAEI,QAAS,OAAQC,eAAgB,SAAUC,WAAY,UAArE,UACE,qBAAKN,MAAO,CAAEC,MAAO,GAAIC,OAAQ,GAAInC,aAAc,GAAI4C,gBAAiB,WACxE,qBAAKX,MAAO,CAAEC,MAAO,GAAIC,OAAQ,GAAInC,aAAc,GAAI4C,gBAAiB,QAASC,SAAU,iBAG7F,6BAEArE,EAAKE,MAAQ0C,EAAW,IAAM5C,EAAKG,MAAQyC,EAAW,GACtD,sBAAKa,MAAO,CAAEI,QAAS,OAAQC,eAAgB,SAAUC,WAAY,UAArE,UACE,qBAAKN,MAAO,CAAEC,MAAO,GAAIC,OAAQ,GAAInC,aAAc,GAAI4C,gBAAiB,SACxE,qBAAKX,MAAO,CAAEC,MAAO,GAAIC,OAAQ,GAAInC,aAAc,GAAI4C,gBAAiB,QAASC,SAAU,iBAG7F,gCAMR,OACE,sBAAKZ,MAAO,CAAEE,OAAQ1C,OAAOwB,YAAa6B,SAAU,UAApD,UACE,sBAAKb,MAAO,CAAEE,OAAQ,IAAKD,MAAO,OAAQU,gBAAiB,QAA3D,UACE,cAACG,EAAA,EAAD,CACEC,QAAQ,YACRC,MAAM,UACNhB,MAAO,CAAEC,MAAO,KAChBgB,QAAS,YFpEZ,YACN,IADoD,IAAD,mBAAnBC,EAAmB,KAAPC,EAAO,KAC1C9C,EAAI,EAAGA,GAAK6C,EAAWrE,OAAQwB,IAAK,CAC5C,GAAIA,IAAM6C,EAAWrE,OAMpB,YALAG,YAAW,WACV,IAAK,IAAI0C,EAAIyB,EAAKtE,OAAS,EAAG6C,GAAK,EAAGA,IACrC1B,EAAYmD,EAAKzB,GAAIyB,EAAKtE,OAAS6C,KAElC,GAAKrB,EAAI,KAIbvB,EADWoE,EAAW7C,GACFA,IE0DV+C,CFxHL,SAAkBnC,EAAcE,EAAY7C,GAQlD,IAPA,IAAI2D,EAAQ3D,EAAK,GAAGO,OAChBwE,EAAQ,CAACpC,GACTqC,EAAU,GACVC,EAAO,GACPC,EAAS,GACTC,GAAQ,EACRN,EAAO,GACF9C,EAAI,EAAGA,EAAI/B,EAAKO,OAAQwB,IAAK,CAGrC,IAFA,IAAIqD,EAAQ,GACRC,EAAM,GACDjC,EAAI,EAAGA,EAAIO,EAAOP,IAC1BgC,EAAM9E,MAAK,GACX+E,EAAI/E,MAAM,GAEX0E,EAAQ1E,KAAK8E,GACbH,EAAK3E,KAAK+E,GAEX,KAAON,EAAMxE,OAAS,IAAM4E,GAAO,CAClC,IAAIlF,EAAO8E,EAAM,GACjBA,EAAMO,OAAO,EAAG,GAChBN,EAAQ/E,EAAKE,KAAKF,EAAKG,MAAO,EAC9B,IAAIyB,EAAa/B,EAAcG,EAAMD,GACrC,IAAS+B,EAAI,EAAGA,EAAIF,EAAWtB,OAAQwB,IAAK,CAC3C,IAAI7B,EAAY2B,EAAWE,GAC3B,GAAI7B,EAAUC,MAAQ0C,EAAW,IAAM3C,EAAUE,MAAQyC,EAAW,GAAI,CACvEqC,EAAO5E,KAAKJ,GACZiF,GAAQ,EACRF,EAAK/E,EAAUC,KAAKD,EAAUE,KAAOH,EACrC,MAEI+E,EAAQ9E,EAAUC,KAAKD,EAAUE,OACrC2E,EAAMzE,KAAKJ,GACX8E,EAAQ9E,EAAUC,KAAKD,EAAUE,MAAO,EACxC6E,EAAK/E,EAAUC,KAAKD,EAAUE,KAAOH,EACrCiF,EAAO5E,KAAKJ,KAIf,GAAIiF,EAAO,CACV,IAAII,EAAML,EAAOA,EAAO3E,OAAS,GAEjC,IADAsE,EAAKvE,KAAKiF,GACHA,GAAO5C,GACbkC,EAAKvE,KAAKiF,GACVA,EAAMN,EAAKM,EAAIpF,KAAKoF,EAAInF,KAEzByE,EAAKvE,KAAKqC,GAEX,MAAO,CAACuC,EAAQL,GEwEWW,CAASxF,EAAK2C,EAAa,IAAIA,EAAa,IAAKE,EAAY7C,KALjF,mBAUA,cAACwE,EAAA,EAAD,CACEC,QAAQ,YACRC,MAAM,UACNhB,MAAO,CAAEC,MAAO,KAChBgB,QAAS,WACPpC,EAAQH,GACRQ,EAAgB,CAAC5B,KAAKC,OAAOC,OAAOwB,YAAc,KAAO,IAAK1B,KAAKC,MAAMC,OAAOC,WAAa,MAC7F2B,EAAc,CAAC9B,KAAKC,OAAOC,OAAOwB,YAAc,KAAO,IAAK1B,KAAKC,MAA0B,EAApBC,OAAOC,WAAiB,MAC/FR,YAAM,CACJC,QAAS,QACTY,WAAY,aAVlB,mBAgBA,cAACgD,EAAA,EAAD,CACEC,QAAQ,YACRC,MAAM,UACNhB,MAAO,CAAEC,MAAO,KAChBgB,QAAS,YDyDZ,SAA2Bc,EAAOzF,EAAMuC,GAC7C5B,YAAM,CACJC,QAAS,QACTY,WAAY,UACZD,SAAU,IACVD,OAAQ,WAEVZ,YAAW,WAET,IADA,IAAIqB,EAAI,EACDA,EAAI0D,EAAMlF,OAAQwB,IACvBG,EAAYuD,EAAM1D,GAAIA,EAAG/B,KAE1B,KCpEO0F,CD7CL,SAAoB1F,EAAMuC,GAM/B,IALA,IAAIyC,EAAU,GACVd,EAAO,YAAOlE,GACd+E,EAAQ,CAACb,EAAQ,GAAG,IACpBuB,EAAQ,GAEH1D,EAAI,EAAGA,EAAImC,EAAQ3D,OAAQwB,IAAK,CAEvC,IADA,IAAIqD,EAAQ,GACHhC,EAAI,EAAGA,EAAIc,EAAQ,GAAG3D,OAAQ6C,IACrCgC,EAAM9E,MAAK,GACX4D,EAAQnC,GAAGqB,GAAG/C,QAAS,EAEzB2E,EAAQ1E,KAAK8E,GAEf,KAAOL,EAAMxE,OAAS,GAAG,CACvB,GAAIwE,EAAMxE,QAAU,EAAG,CACrB,IACIN,EAAO8E,EADPY,EAAY3E,KAAKC,MAAsB,EAAhBD,KAAK4E,WAEhCb,EAAMO,OAAOK,EAAW,OACnB,CACL,IAAIA,EACA1F,EAAO8E,EADPY,EAAY3E,KAAKC,MAAMD,KAAK4E,SAAWb,EAAMxE,SAEjDwE,EAAMO,OAAOK,EAAW,GAE1B,IAAKX,EAAQ/E,EAAKE,KAAKF,EAAKG,MAAQwB,EAAmB3B,EAAMiE,IAAYlC,EAAmB/B,EAAMiE,GAAU,CAC1GuB,EAAMnF,KAAKL,GACXiE,EAAQjE,EAAKE,KAAKF,EAAKG,KAAKC,QAAS,EACrC2E,EAAQ/E,EAAKE,KAAKF,EAAKG,MAAO,EAC9B,IAAIyB,EAAaI,EAAoBhC,EAAMiE,GAC3C,IAASnC,EAAI,EAAGA,EAAIF,EAAWtB,OAAQwB,IACrCgD,EAAMc,QAAQhE,EAAWE,KAI/B,OAAO0D,ECWqBK,CAAW9F,GAAgBA,IALjD,qBAYF,8BAtJJ,SAAoBA,GAClB,OACE,qBAAK0D,MAAO,CAAEI,QAAS,OAAQiC,cAAe,SAAU/B,WAAY,UAApE,SACGhE,EAAKgG,KAAI,SAAC7F,GACT,OACE,qBAAKuD,MAAO,CAAEI,QAAS,OAAQiC,cAAe,OAA9C,SACG5F,EAAI6F,KAAI,SAAA/F,GACP,OAAOsD,EAAWtD,aAgJzBgG,CAAWjG,SC9KLkG,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFhG,SAASC,eAAe,SAM1BoF,M","file":"static/js/main.c7188e65.chunk.js","sourcesContent":["import anime from 'animejs/lib/anime.es'\n\nfunction getNeighbours(curNode, grid) {\n\tvar neighbour = []\n\n\tif (curNode.row > 0) {\n\t\tvar node = grid[curNode.row - 1][curNode.col]\n\t\tif (!node.isWall) {\n\t\t\tneighbour.push(node)\n\t\t}\n\t}\n\tif (curNode.col < grid[0].length - 1) {\n\t\tvar node = grid[curNode.row][curNode.col + 1]\n\t\tif (!node.isWall) {\n\t\t\tneighbour.push(node)\n\t\t}\n\t}\n\tif (curNode.row < grid.length - 1) {\n\t\tvar node = grid[curNode.row + 1][curNode.col]\n\t\tif (!node.isWall) {\n\t\t\tneighbour.push(node)\n\t\t}\n\t}\n\tif (curNode.col > 0) {\n\t\tvar node = grid[curNode.row][curNode.col - 1]\n\t\tif (!node.isWall) {\n\t\t\tneighbour.push(node)\n\t\t}\n\t}\n\treturn neighbour\n}\n\nexport function dijkstra(startingNode, endingNode, grid) {\n\tvar width = grid[0].length\n\tvar queue = [startingNode]\n\tvar visited = []\n\tvar prev = []\n\tvar result = []\n\tvar found = false\n\tvar path = []\n\tfor (var i = 0; i < grid.length; i++) {\n\t\tvar visit = []\n\t\tvar pre = []\n\t\tfor (var j = 0; j < width; j++) {\n\t\t\tvisit.push(false)\n\t\t\tpre.push(-1)\n\t\t}\n\t\tvisited.push(visit)\n\t\tprev.push(pre)\n\t}\n\twhile (queue.length > 0 && !found) {\n\t\tvar node = queue[0]\n\t\tqueue.splice(0, 1)\n\t\tvisited[node.row][node.col] = true\n\t\tvar neighbours = getNeighbours(node, grid)\n\t\tfor (var i = 0; i < neighbours.length; i++) {\n\t\t\tvar neighbour = neighbours[i]\n\t\t\tif (neighbour.row === endingNode[0] && neighbour.col === endingNode[1]) {\n\t\t\t\tresult.push(neighbour)\n\t\t\t\tfound = true\n\t\t\t\tprev[neighbour.row][neighbour.col] = node\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (!visited[neighbour.row][neighbour.col]) {\n\t\t\t\tqueue.push(neighbour)\n\t\t\t\tvisited[neighbour.row][neighbour.col] = true\n\t\t\t\tprev[neighbour.row][neighbour.col] = node\n\t\t\t\tresult.push(neighbour)\n\t\t\t}\n\t\t}\n\t}\n\tif (found) {\n\t\tvar cur = result[result.length - 1]\n\t\tpath.push(cur)\n\t\twhile (cur != startingNode) {\n\t\t\tpath.push(cur)\n\t\t\tcur = prev[cur.row][cur.col]\n\t\t}\n\t\tpath.push(startingNode)\n\t}\n\treturn [result, path]\n}\n\nexport function animateDijkstra([visitOrder, path]) {\n\tfor (var i = 0; i <= visitOrder.length; i++) {\n\t\tif (i === visitOrder.length) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tfor (var j = path.length - 1; j >= 0; j--) {\n\t\t\t\t\tanimatePath(path[j], path.length - j)\n\t\t\t\t}\n\t\t\t}, 10 * i + 100)\n\t\t\treturn\n\t\t}\n\t\tvar node = visitOrder[i]\n\t\tanimateSearch(node, i)\n\t}\n}\n\nfunction animateSearch(node, time) {\n\tsetTimeout(() => {\n\t\tanime({\n\t\t\ttargets: document.getElementById(\"node\".concat(node.row * Math.floor(window.innerWidth / 20) + node.col)),\n\t\t\tscale: [\n\t\t\t\t{ value: 1.1, easing: 'easeOutSine', duration: 500 },\n\t\t\t\t{ value: 1, easing: 'easeInOutQuad', duration: 1200 }\n\t\t\t],\n\t\t\tbackground: [\n\t\t\t\t{ value: '#0CECDD', easing: 'linear', duration: 500 },\n\t\t\t\t{ value: '#88FFF7', easing: 'linear', duration: 500 },\n\t\t\t],\n\t\t\tborderRadius: [\n\t\t\t\t{ value: '20%', easing: 'linear', duration: 1000 },\n\t\t\t\t{ value: '0%', easing: 'linear', duration: 500 },\n\t\t\t],\n\t\t})\n\t}, 10 * time)\n}\n\nfunction animatePath(node, time) {\n\tsetTimeout(() => {\n\t\tanime({\n\t\t\ttargets: document.getElementById(\"node\".concat(node.row * Math.floor(window.innerWidth / 20) + node.col)),\n\t\t\tscale: [\n\t\t\t\t{ value: 1.1, easing: 'easeOutSine', duration: 500 },\n\t\t\t\t{ value: 1, easing: 'easeInOutQuad', duration: 1200 }\n\t\t\t],\n\t\t\tbackground: [\n\t\t\t\t{ value: '#FFD371', easing: 'linear', duration: 500 },\n\t\t\t\t{ value: '#FFF338', easing: 'linear', duration: 500 },\n\t\t\t],\n\t\t\tborderRadius: [\n\t\t\t\t{ value: '20%', easing: 'linear', duration: 1000 },\n\t\t\t\t{ value: '0%', easing: 'linear', duration: 500 },\n\t\t\t],\n\t\t})\n\t}, 50 * time)\n}\n\n\n","import anime from 'animejs/lib/anime.es'\n\nexport function randomizeDepthFirstSearch(grid, setGrid) {\n  var visited = []\n  var newGrid = [...grid]\n  var queue = [newGrid[1][2]]\n  var order = []\n\n  for (var i = 0; i < newGrid.length; i++) {\n    var visit = []\n    for (var j = 0; j < newGrid[0].length; j++) {\n      visit.push(false)\n    }\n    visited.push(visit)\n  }\n\n  for (var i = 0; i < grid[0].length; i++) {\n    newGrid[0][i].isWall = true\n    order.push(newGrid[0][i])\n  }\n  for (var i = 1; i < grid.length; i++) {\n    newGrid[i][grid[0].length - 1].isWall = true\n    order.push(newGrid[i][grid[0].length - 1])\n  }\n  for (var i = grid[0].length - 1; i >= 0; i--) {\n    newGrid[grid.length - 1][i].isWall = true\n    order.push(newGrid[grid.length - 1][i])\n  }\n  for (var i = grid.length - 1; i >= 0; i--) {\n    newGrid[i][0].isWall = true\n    order.push(newGrid[i][0])\n  }\n  while (queue.length > 0) {\n    if (queue.length >= 4) {\n      var randIndex = Math.floor(Math.random() * 4)\n      var node = queue[randIndex]\n      queue.splice(randIndex, 1)\n    } else {\n      var randIndex = Math.floor(Math.random() * queue.length)\n      var node = queue[randIndex]\n      queue.splice(randIndex, 1)\n    }\n    if (!visited[node.row][node.col] && checkAdjacent(node, newGrid) && checkDiagonal(node, newGrid)) {\n      order.push(node)\n      newGrid[node.row][node.col].isWall = true\n      visited[node.row][node.col] = true\n      var neighbours = thisGetNeighbours(node, newGrid)\n      for (var i = 0; i < neighbours.length; i++) {\n        queue.unshift(neighbours[i])\n      }\n    }\n  }\n  return order\n}\n\nexport function animateDfsMaze(order, grid, setGrid) {\n  var i = 0\n  for (; i < order.length; i++) {\n    change(order[i], i, grid)\n  }\n  setTimeout(() => setGrid(grid), i * 15)\n  return\n}\n\nfunction change(node, time, grid) {\n  setTimeout(() => {\n    anime({\n      targets: document.getElementById(\"node\".concat(node.row * grid[0].length + node.col)),\n      background: '#000000'\n    })\n  }, 15 * time)\n}\n\nfunction thisGetNeighbours(curNode, grid) {\n  var neighbour = []\n  if (curNode.row > 0) {\n    var node = grid[curNode.row - 1][curNode.col]\n    neighbour.push(node)\n  }\n  if (curNode.col < grid[0].length - 1) {\n    var node = grid[curNode.row][curNode.col + 1]\n    neighbour.push(node)\n  }\n  if (curNode.row < grid.length - 1) {\n    var node = grid[curNode.row + 1][curNode.col]\n    neighbour.push(node)\n  }\n  if (curNode.col > 0) {\n    var node = grid[curNode.row][curNode.col - 1]\n    neighbour.push(node)\n  }\n  return neighbour\n}\n\nfunction checkAdjacent(node, grid) {\n  var neighbours = thisGetNeighbours(node, grid)\n  var count = 0\n  for (var i = 0; i < neighbours.length; i++) {\n    if (neighbours[i].isWall) {\n      count++\n    }\n    if (count >= 2) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction checkDiagonal(node, grid) {\n  if (node.row > 0 && node.col > 0) {\n    if (grid[node.row - 1][node.col - 1].isWall && !grid[node.row - 1][node.col].isWall && !grid[node.row][node.col - 1].isWall) {\n      return false\n    }\n  }\n  if (node.row > 0 && node.col < grid[0].length - 1) {\n    if (grid[node.row - 1][node.col + 1].isWall && !grid[node.row - 1][node.col].isWall && !grid[node.row][node.col + 1].isWall) {\n      return false\n    }\n  }\n  if (node.row < grid.length - 1 && node.col > 0) {\n    if (grid[node.row + 1][node.col - 1].isWall && !grid[node.row + 1][node.col].isWall && !grid[node.row][node.col - 1].isWall) {\n      return false\n    }\n  }\n  if (node.row < grid.length - 1 && node.col < grid[0].length - 1) {\n    if (grid[node.row + 1][node.col + 1].isWall && !grid[node.row + 1][node.col].isWall && !grid[node.row][node.col + 1].isWall) {\n      return false\n    }\n  }\n  return true\n}\n\n\nexport function createPath(grid, setGrid) {\n  var visited = []\n  var newGrid = [...grid]\n  var queue = [newGrid[1][1]]\n  var order = []\n\n  for (var i = 0; i < newGrid.length; i++) {\n    var visit = []\n    for (var j = 0; j < newGrid[0].length; j++) {\n      visit.push(false)\n      newGrid[i][j].isWall = true;\n    }\n    visited.push(visit)\n  }\n  while (queue.length > 0) {\n    if (queue.length >= 4) {\n      var randIndex = Math.floor(Math.random() * 4)\n      var node = queue[randIndex]\n      queue.splice(randIndex, 1)\n    } else {\n      var randIndex = Math.floor(Math.random() * queue.length)\n      var node = queue[randIndex]\n      queue.splice(randIndex, 1)\n    }\n    if (!visited[node.row][node.col] && checkEmptyAdjacent(node, newGrid) && checkEmptyDiagonal(node, newGrid)) {\n      order.push(node)\n      newGrid[node.row][node.col].isWall = false\n      visited[node.row][node.col] = true\n      var neighbours = anotherGetNeighbour(node, newGrid)\n      for (var i = 0; i < neighbours.length; i++) {\n        queue.unshift(neighbours[i])\n      }\n    }\n  }\n  return order\n}\n\nfunction checkEmptyAdjacent(node, grid) {\n  var neighbours = thisGetNeighbours(node, grid)\n  var count = 0\n  for (var i = 0; i < neighbours.length; i++) {\n    if (!neighbours[i].isWall) {\n      count++\n    }\n    if (count >= 2) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction checkEmptyDiagonal(node, grid) {\n  if (node.row > 0 && node.col > 0) {\n    if (!grid[node.row - 1][node.col - 1].isWall && grid[node.row - 1][node.col].isWall && grid[node.row][node.col - 1].isWall) {\n      return false\n    }\n  }\n  if (node.row > 0 && node.col < grid[0].length - 1) {\n    if (!grid[node.row - 1][node.col + 1].isWall && grid[node.row - 1][node.col].isWall && grid[node.row][node.col + 1].isWall) {\n      return false\n    }\n  }\n  if (node.row < grid.length - 1 && node.col > 0) {\n    if (!grid[node.row + 1][node.col - 1].isWall && grid[node.row + 1][node.col].isWall && grid[node.row][node.col - 1].isWall) {\n      return false\n    }\n  }\n  if (node.row < grid.length - 1 && node.col < grid[0].length - 1) {\n    if (!grid[node.row + 1][node.col + 1].isWall && grid[node.row + 1][node.col].isWall && grid[node.row][node.col + 1].isWall) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction anotherGetNeighbour(node, grid) {\n  var neighbour = []\n  if (node.row > 1) {\n    neighbour.push(grid[node.row - 1][node.col])\n  }\n  if (node.col < grid[0].length - 2) {\n    neighbour.push(grid[node.row][node.col + 1])\n  }\n  if (node.row < grid.length - 2) {\n    neighbour.push(grid[node.row + 1][node.col])\n  }\n  if (node.col > 1) {\n    neighbour.push(grid[node.row][node.col - 1])\n  }\n  return neighbour\n}\n\nfunction changeWhite(node, time, grid) {\n  setTimeout(() => {\n    anime({\n      targets: document.getElementById(\"node\".concat(node.row * grid[0].length + node.col)),\n      background: '#FFFFFF'\n    })\n  }, 15 * time)\n}\n\nexport function anotherAnimateDfs(order, grid, setGrid) {\n  anime({\n    targets: '.node',\n    background: '#000000',\n    duration: 750,\n    easing: 'linear'\n  })\n  setTimeout(() => {\n    var i = 0\n    for (; i < order.length; i++) {\n      changeWhite(order[i], i, grid)\n    }\n  }, 1000)\n\n  return\n}","import './App.css';\nimport anime from 'animejs/lib/anime.es.js';\nimport React, { useState } from 'react';\nimport { Button } from '@material-ui/core';\nimport { dijkstra, animateDijkstra } from './pathFindingFunctions';\nimport { animateDfsMaze, randomizeDepthFirstSearch, createPath, anotherAnimateDfs } from './mazeFunctions/randomizedDfsMaze'\n\nfunction App() {\n\n  const blankGrid = createGrid()\n  const [grid, setGrid] = useState(createGrid())\n  const [isMousePressed, setIsMousePressed] = useState(false)\n  const [startingNode, setStartingNode] = useState([Math.floor((window.innerHeight - 200) / 40), Math.floor(window.innerWidth / 80)])\n  const [endingNode, setEndingNode] = useState([Math.floor((window.innerHeight - 200) / 40), Math.floor(window.innerWidth * 3 / 80)])\n  const [isMovingStart, setIsMovingStart] = useState(false)\n  const [isMovingEnd, setIsMovingEnd] = useState(false)\n\n  function createGrid() {\n    var grids = []\n    for (var i = 0; i < Math.floor((window.innerHeight - 200) / 20); i++) {\n      var row = []\n      for (var j = 0; j < Math.floor(window.innerWidth / 20); j++) {\n        row.push({\n          row: i,\n          col: j,\n          isWall: false,\n          isStart: false,\n          isEnd: false\n        })\n      }\n      grids.push(row)\n    }\n    return grids\n  }\n\n  function renderGrid(grid) {\n    return (\n      <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>\n        {grid.map((row) => {\n          return (\n            <div style={{ display: 'flex', flexDirection: 'row' }}>\n              {row.map(node => {\n                return createNode(node)\n              })}\n            </div>\n          )\n        })}\n      </div>\n    )\n  }\n\n  function createNode(node) {\n    return (\n      <div\n        className='node'\n        id={\"node\".concat(Math.floor(window.innerWidth / 20) * node.row + node.col)}\n        style={{ width: 18, height: 18, border: '1px solid #7DEDFF', display: 'flex', justifyContent: 'center', alignItems: 'center' }}\n        onMouseDown={() => {\n          if ((node.row === startingNode[0] && node.col === startingNode[1])) {\n            setIsMovingStart(true)\n            return\n          }\n          if ((node.row === endingNode[0] && node.col === endingNode[1])) {\n            setIsMovingEnd(true)\n            return\n          }\n          var newGrid = [...grid]\n          var curNode = newGrid[node.row][node.col]\n          curNode.isWall = !node.isWall\n          newGrid[node.row][node.col] = curNode\n          setGrid(newGrid)\n          setIsMousePressed(true)\n        }}\n        onMouseEnter={() => {\n          if (isMovingStart) {\n            if ((node.row === endingNode[0] && node.col === endingNode[1])) { return }\n            if (node.isWall) {\n              var newGrid = [...grid]\n              var curNode = newGrid[node.row][node.col]\n              curNode.isWall = !node.isWall\n              newGrid[node.row][node.col] = curNode\n              setGrid(newGrid)\n            }\n            setStartingNode([node.row, node.col])\n\n          }\n          if (isMovingEnd) {\n            if ((node.row === startingNode[0] && node.col === startingNode[1])) { return }\n            if (node.isWall) {\n              var newGrid = [...grid]\n              var curNode = newGrid[node.row][node.col]\n              curNode.isWall = !node.isWall\n              newGrid[node.row][node.col] = curNode\n              setGrid(newGrid)\n            }\n            setEndingNode([node.row, node.col])\n\n          }\n          if (isMousePressed) {\n            var newGrid = [...grid]\n            var curNode = newGrid[node.row][node.col]\n            curNode.isWall = !node.isWall\n            newGrid[node.row][node.col] = curNode\n            setGrid(newGrid)\n          }\n        }}\n        onMouseUp={() => {\n          if (isMovingStart) {\n            setIsMovingStart(false)\n          }\n          if (isMovingEnd) {\n            setIsMovingEnd(false)\n          }\n          if (isMousePressed) {\n            setIsMousePressed(false)\n          }\n\n        }}\n      >\n        {(node.isWall) ? (\n          <div style={{ width: 18, height: 18, backgroundColor: 'black' }} />\n        ) : (\n          <></>\n        )}\n        {(node.row === startingNode[0] && node.col === startingNode[1]) ? (\n          <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>\n            <div style={{ width: 18, height: 18, borderRadius: 18, backgroundColor: 'black' }} />\n            <div style={{ width: 12, height: 12, borderRadius: 12, backgroundColor: 'white', position: 'absolute' }} />\n          </div>\n        ) : (\n          <></>\n        )}\n        {(node.row === endingNode[0] && node.col === endingNode[1]) ? (\n          <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>\n            <div style={{ width: 18, height: 18, borderRadius: 18, backgroundColor: 'red' }} />\n            <div style={{ width: 12, height: 12, borderRadius: 12, backgroundColor: 'green', position: 'absolute' }} />\n          </div>\n        ) : (\n          <></>\n        )}\n      </div>\n    )\n  }\n\n  return (\n    <div style={{ height: window.innerHeight, overflow: 'hidden' }}>\n      <div style={{ height: 200, width: '100%', backgroundColor: 'teal' }}>\n        <Button\n          variant=\"contained\"\n          color=\"primary\"\n          style={{ width: 100 }}\n          onClick={() => {\n            animateDijkstra(dijkstra(grid[startingNode[0]][startingNode[1]], endingNode, grid))\n          }}\n        >\n          Start\n        </Button>\n        <Button\n          variant=\"contained\"\n          color=\"primary\"\n          style={{ width: 100 }}\n          onClick={() => {\n            setGrid(blankGrid)\n            setStartingNode([Math.floor((window.innerHeight - 200) / 40), Math.floor(window.innerWidth / 80)])\n            setEndingNode([Math.floor((window.innerHeight - 200) / 40), Math.floor(window.innerWidth * 3 / 80)])\n            anime({\n              targets: '.node',\n              background: '#FFFFFF'\n            })\n          }}\n        >\n          Reset\n        </Button>\n        <Button\n          variant=\"contained\"\n          color=\"primary\"\n          style={{ width: 100 }}\n          onClick={() => {\n            anotherAnimateDfs(createPath(grid, setGrid), grid, setGrid)\n          }}\n        >\n          Maze\n        </Button>\n      </div>\n\n      <div >\n        {renderGrid(grid)}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}